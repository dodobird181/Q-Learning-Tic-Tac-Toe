import pygame
import settings

'''
'
' The GameObject class is used as a basic template for all objects that are
' going to be displayed, and / or updated, in the game. The main function of 
' this abstract class is to allow a unanimous call to the 'update()' method
' on ALL game objects, while allowing for some higher-level GameObject
' implementations to avoid implementing a useless 'update()' method themselves.
'
'''
class GameObject():
	 
	def draw(self):
		pass

	def update(self):
		pass

'''
'
' The ClickableGameObject class's usefulness is twofold. On the one hand, the
' class acts as a way for the event handler to idenfity clickable objects, which
' allows the event handler to funnel click events downwards to each ClickableGameObject.
' And, on the other hand, the class acts as a template for clickable game objects,
' implementing the necessary methods so higher-level classes needen't implement every
' method required by the event handler.
'
'''
class ClickableGameObject(GameObject):

	rect = None

	def mouse_over(self):
		pass

	def mouse_not_over(self):
		pass

	def mouse_down(self):
		pass

	def mouse_up(self):
		pass

'''
'
' The ScreenState class acts like a wrapper for multiple game objects,
' conncting them to the game loop's 'update()', and 'draw()', methods.
'
'''
class ScreenState():

	def __init__(self, state_name):
		self.state_name = state_name
		self.object_list = []

	def draw(self, window):
		for o in self.object_list:
			o.draw(window)

	def update(self):
		for o in self.object_list:
			o.update()

	def add_object(self, o):
		self.object_list.append(o)

	def add_message(self, m, size, x_off, y_off, t_c = (0,0,0), b_c = (255,255,255)):
		gm = GameMessage(m, size, t_c, b_c)
		gm.center()
		gm.rect.x += x_off
		gm.rect.y += y_off
		self.add_object(gm)

	def add_button(self, m, size, x_off, y_off, func, m_o_c = (180,180,180), m_d_c = (140,140,140), t_c = (0,0,0), b_c = (220,220,220)):
		gb = GameButton(m, size, func, m_o_c, m_d_c, t_c, b_c)
		gb.center()
		gb.rect.x += x_off
		gb.rect.y += y_off
		self.add_object(gb)

'''
'
' ...
'
'''
class EventHandler():

	#Init function
	def __init__(self, game_instance):
		self.gi = game_instance
		self.mouse_events = [pygame.MOUSEBUTTONUP, pygame.MOUSEBUTTONDOWN, pygame.MOUSEMOTION]
		self.scheduled_events = {}

	#Called by the game-loop's 'update()' method to handle all game events.
	def handle(self):
		for e in pygame.event.get():

			#Exits the game if the 'x' is clicked
			if e.type == pygame.QUIT:
				self.gi.running = False

			#Handles all mouse clicks
			if e.type in self.mouse_events:
				self.handle_mouse_events(e)

			#Handles all custom events
			if e.type in self.scheduled_events:
				self.scheduled_events[e.type][0](self.scheduled_events[e.type][1])

	#Adds a custom event to be scheduled every 'delay' milliseconds. When this
	#event is triggered by pygame's built-in timer, it will call the function 'func'
	#with parameters 'params' specified when this method is called. The ID param should
	#be generated by using pygame.USEREVENT+n, where 'n' is the number of your custom
	#event. Please keep track of your custom event ID's!!!
	def schedule_event(self, ID, func, params, delay):
		pygame.time.set_timer(ID, delay)
		my_event = [func, params]
		self.scheduled_events[ID] = my_event

	#Handles ALL mouse events for ClickableGameObjects.
	def handle_mouse_events(self, e):

		#Cycles through every GameObject in the state's object_list and
		#singles out the ClickableGameObjects, then calls the appropriate
		#click method based on which pygame event triggered this method.
		for o in self.gi.state().object_list:
			if isinstance(o, ClickableGameObject):
				try:
					mouse_pos = pygame.mouse.get_pos()
					if o.rect.collidepoint(mouse_pos):
						if e.type == pygame.MOUSEBUTTONUP:
							o.mouse_up()
						elif e.type == pygame.MOUSEBUTTONDOWN:
							o.mouse_down()

						#Chooses only one mouse event to send mouse_over() calls from.
						# Otherwise mouse_over() would be called once for every mouse event 
						#in the mouse_events list! In this case, the mouse_over() function is
						#only called when a pygame.MOUSEMOTION event occurs.
						if e.type == self.mouse_events[2]:
							o.mouse_over()
					else:
						if e.type == self.mouse_events[2]:### same thing as above ^^^
							o.mouse_not_over()            ### but for mouse_not_over()
				except AttributeError as e:
					print(e)
					print('ERROR: A ClickableGameObject has been created without defining a pygame "rect" to be clicked!')

'''
'
' ...
'
'''
class GameMessage(ClickableGameObject):

	#Init function, m = message, t_c and b_c stand for 
	#text color and background color respectivly.
	def __init__(self, m, size, t_c = (0,0,0), b_c = (255,255,255)):
		self.m = m
		self.font = pygame.font.Font('freesansbold.ttf', size)
		self.t_c = t_c
		self.b_c = b_c
		self.text = self.font.render(m, True, t_c, b_c)
		self.rect = self.text.get_rect()
		self.show = True

	def draw(self, window):
		if self.show == True:
			window.blit(self.text, self.rect)

	#Function that assigns a new position for the pygame
	#rectangle that contains the message
	def put(self, x, y):
		self.rect.x = x
		self.rect.y = y

	#Function that moves the rectangle containing the message
	def move(self, x_add, y_add):
		self.rect.x += x
		self.rect.y += y

	#Moves the rectangle containing the message to the center of the screen
	def center(self):
		self.rect.center = (int(settings.screen_width/2), int(settings.screen_height/2))

'''
'
' ...
'
'''
class GameButton(GameMessage):

	#Init Function, m_o_c = 'mouse over color', and m_d_c = 'mouse down color'
	def __init__(self, m, size, func, m_o_c = (180,180,180), m_d_c = (140,140,140), t_c = (0,0,0), b_c = (255,255,255)):
		super().__init__(m, size, t_c, b_c)
		self.func = func
		self.m_o_c = m_o_c
		self.m_d_c = m_d_c

	def mouse_over(self):
		self.text = self.font.render(self.m, True, self.t_c, self.m_o_c)

	def mouse_not_over(self):
		self.text = self.font.render(self.m, True, self.t_c, self.b_c)

	def mouse_down(self):
		self.text = self.font.render(self.m, True, self.t_c, self.m_d_c)

	def mouse_up(self):
		self.func()